import io.github.ran.jarmerger.JarMergerPlugin

buildscript {
    dependencies{
        classpath files('plugins/DHJarMerger-1.0.jar')
    }
}

plugins {
    id "architectury-plugin" version "3.4-SNAPSHOT"
    id "dev.architectury.loom" version "0.12.0-SNAPSHOT" apply false
}

apply plugin: "java"
apply plugin: "architectury-plugin"
apply plugin: "maven-publish"
apply plugin: JarMergerPlugin

archivesBaseName = rootProject.archives_base_name
version = rootProject.mod_version
group = rootProject.maven_group

task printConfigurations {
    doLast {task ->
        println "Project Name: $name configurations:"
        configurations.each {
            println "    $it.name"
        }
    }
}

def writeBuildGradlePredefine(List<String> mcVers, int mcIndex) {
    ArrayList<String> redefineList = new ArrayList<String>()
    for (int i=0; i<mcVers.size(); i++) {
        String mcStr = mcVers.get(i).replace(".", "_")
        if (mcIndex<i) {
            redefineList.add("PRE_MC_"+mcStr)
        }
        if (mcIndex==i) {
            redefineList.add("MC_"+mcStr)
        }
        if (mcIndex>=i) {
            redefineList.add("POST_MC_"+mcStr)
        }
    }
    StringBuilder sb = new StringBuilder()
    for (String s : redefineList) {
        sb.append(s)
        sb.append("=\n")
    }
    new File(projectDir, "build.properties").text = sb.toString()
}

// Sets up the variables for Manifold in the code
def loadProperties() {
    def defaultMcVersion = "1.19.2"
    def mcVersion = ""
    def mcVers = mcVersions.split(",")
    int mcIndex = -1
    println "Avalible MC versions: ${mcVersions}"
    if (project.hasProperty("mcVer")) {
        mcVersion = mcVer
        mcIndex = Arrays.asList(mcVers).indexOf(mcVer)
    }
    if (mcIndex == -1) {
        println "No mcVer set or the set mcVer is invalid! Defaulting to ${defaultMcVersion}."
        println "Tip: Use -PmcVer='${defaultMcVersion}' in cmd arg to set mcVer."
        mcVersion = defaultMcVersion
        mcIndex = Arrays.asList(mcVers).indexOf(defaultMcVersion)
        assert mcIndex != -1
    }

	println "Loading properties file at " + mcVersion + ".properties"
	def props = new Properties()
	props.load(new FileInputStream("$rootProject.rootDir/"+"$mcVersion"+".properties"))

    props.each { prop ->
      rootProject.ext.set(prop.key, prop.value)
	  // println "Added prop [key:" + prop.key + ", value:" + prop.value + "]"
    }
    writeBuildGradlePredefine(Arrays.asList(mcVers), mcIndex)

    // Stuff for access wideners
    def mcVersionToAcsessWidenerVersion = [
            "1.16.5": "1_16",
            "1.17.1": "1_17",
            "1.18.1": "1_18",
            "1.18.2": "1_18",
            "1.19.1"  : "1_19",
			"1.19.2"  : "1_19",
            "1.19.3"  : "1_19_3"
    ]
    // Use this as sometimes multiple versions use the same access wideners
    rootProject.ext.set("acsessWidenerVersion", mcVersionToAcsessWidenerVersion.get(mcVersion))
}
loadProperties()

architectury {
    minecraft = rootProject.minecraft_version
}

repositories {
    mavenCentral()

    // For parchment mappings
    maven { url "https://maven.parchmentmc.org" }

    // used to download and compile dependencies from git repos
    maven { url 'https://jitpack.io' }

    // For Manifold Preprocessor
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }

    // Required for importing Modrinth mods
    maven {
        name = "Modrinth"
        url = "https://api.modrinth.com/maven"
        content {
            includeGroup "maven.modrinth"
        }
    }

    // Required for importing CursedForge mods
    maven {
        url "https://www.cursemaven.com"
        content {
            includeGroup "curse.maven"
        }
    }

    // These 2 are for importing mods that arnt on CursedForge, Modrinth, GitHub, GitLab or anywhere opensource
    flatDir {
        dirs "${rootDir}/mods/fabric"
        content {
            includeGroup "fabric-mod"
        }
    }
    flatDir {
        dirs "${rootDir}/mods/forge"
        content {
            includeGroup "forge-mod"
        }
    }
}

processResources {
    def resourceTargets = ["fabric.mod.json", "META-INF/mods.toml"] // Location of where to put
    def intoTargets = ["$buildDir/resources/main/"] // Location of the built resources folder
    def replaceProperties = [
            version                      : mod_version,
            mod_name                     : mod_name,
            authors                      : mod_authors,
            description                  : mod_description,
            homepage                     : mod_homepage,
            source                       : mod_source,
            issues                       : mod_issues,
            minecraft_version            : minecraft_version,
            compatible_minecraft_versions: compatible_minecraft_versions,
            java_version                 : java_version
    ]
    // The left side is what gets replaced in the mod info and the right side is where to get it from in the gradle.properties
    //TODO: Make Forge loader version also be relaced with non hardcoded value instead of "[36,42)"

    inputs.properties replaceProperties
    replaceProperties.put 'project', project
    filesMatching(resourceTargets) {
        expand replaceProperties
    }

    intoTargets.each { target ->
        if (file(target).exists()) {
            copy {
                from(sourceSets.main.resources) {
                    include resourceTargets
                    expand replaceProperties
                }
                into target
            }
        }
    }
}

// Copies the correct accesswidener and renames it
task copyAccessWidener(type: Copy) {
    from project(":common").file("src/main/resources/${rootProject.acsessWidenerVersion}.lod.accesswidener")
    into(file("build/resources/main"))
    rename "${rootProject.acsessWidenerVersion}.lod.accesswidener", "lod.accesswidener"
}

task copyCoreResources(type: Copy) {
    from fileTree(project(":core").file("src/main/resources"))
    into file("build/resources/main")
}

task copyCommonResources(type: Copy) {
    from fileTree(project(":common").file("src/main/resources"))
    into file("build/resources/main")
}

java {
    withSourcesJar()
}

//runClient.enabled = false
//runServer.enabled = false

// this deletes the merged folder so we don't carry over
// the previous merges to each new build job in the CI/CD pipeline
task deleteMerged(type: Delete) {
   delete files("./Merged")
}


// ===============================CORE Gradle basically================================
subprojects { p ->
    if (p == project(":core")) {

        apply plugin: "java"
        apply plugin: "architectury-plugin"
        apply plugin: "maven-publish"
        apply plugin: "dev.architectury.loom"

        p.archivesBaseName = rootProject.archives_base_name
        p.version = rootProject.mod_version
        p.group = rootProject.maven_group

        loom {
            silentMojangMappingsLicense()
        }

        configurations {
            common
            shadowMe
            implementation.extendsFrom shadowMe
        }

        dependencies {
            minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
            // The following line declares the mojmap mappings & parchment mappings
            mappings loom.layered() {
                // Mojmap mappings
                officialMojangMappings()
                // Parchment mappings (it adds parameter mappings & javadoc)
                if (
                        rootProject.minecraft_version != "1.19"
                        && rootProject.minecraft_version != "1.19.1"
                        && rootProject.minecraft_version != "1.19.2"
                        && rootProject.minecraft_version != "1.19.3"
                ) // We are not gonna use this build script anymore so dont bother fixing this
                    parchment("org.parchmentmc.data:parchment-${rootProject.minecraft_version}:${rootProject.parchment_version}@zip")
                else
                    parchment("org.parchmentmc.data:parchment-1.18.2:${rootProject.parchment_version}@zip") // As 1.19.x or higher doesnt have parchment mappings yet, we use 1.18.2 mapping
            }

            //Manifold
            annotationProcessor "systems.manifold:manifold-preprocessor:${rootProject.manifold_version}"

            // Toml
            implementation("com.electronwill.night-config:toml:${rootProject.toml_version}")

            // We depend on fabric loader here to use the fabric @Environment annotations and get the mixin dependencies
            // Do NOT use other classes from fabric loader unless working with fabric
            modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
        }

        // Allows the jar to run standalone
        jar {
            manifest {
                attributes 'Implementation-Title': rootProject.archives_base_name,
                        'Implementation-Version': rootProject.mod_version,
                        'Main-Class': 'com.seibel.lod.core.JarMain'
                // When changing the main of the jar change this line
            }
        }

        task printConfigurations {
            doLast {task ->
                println "Project Name: $p.name configurations:"
                configurations.each {
                    println "    $it.name"
                }
            }
        }

        repositories {
            mavenCentral()

            // For parchment mappings
            maven { url "https://maven.parchmentmc.org" }

            // used to download and compile dependencies from git repos
            maven { url 'https://jitpack.io' }

            // For Manifold Preprocessor
            maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }

            // Required for importing Modrinth mods
            maven {
                name = "Modrinth"
                url = "https://api.modrinth.com/maven"
                content {
                    includeGroup "maven.modrinth"
                }
            }

            // Required for importing CursedForge mods
            maven {
                url "https://www.cursemaven.com"
                content {
                    includeGroup "curse.maven"
                }
            }

            // These 2 are for importing mods that arnt on CursedForge, Modrinth, GitHub, GitLab or anywhere opensource
            flatDir {
                dirs "${rootDir}/mods/fabric"
                content {
                    includeGroup "fabric-mod"
                }
            }
            flatDir {
                dirs "${rootDir}/mods/forge"
                content {
                    includeGroup "forge-mod"
                }
            }
        }

        processResources {
            def resourceTargets = ["fabric.mod.json", "META-INF/mods.toml"] // Location of where to put
            def intoTargets = ["$buildDir/resources/main/"] // Location of the built resources folder
            def replaceProperties = [
                    version                      : mod_version,
                    mod_name                     : mod_name,
                    authors                      : mod_authors,
                    description                  : mod_description,
                    homepage                     : mod_homepage,
                    source                       : mod_source,
                    issues                       : mod_issues,
                    minecraft_version            : minecraft_version,
                    compatible_minecraft_versions: compatible_minecraft_versions,
                    java_version                 : java_version
            ]
            // The left side is what gets replaced in the mod info and the right side is where to get it from in the gradle.properties
            //TODO: Make Forge loader version also be relaced with non hardcoded value instead of "[36,42)"

            inputs.properties replaceProperties
            replaceProperties.put 'project', project
            filesMatching(resourceTargets) {
                expand replaceProperties
            }

            intoTargets.each { target ->
                if (file(target).exists()) {
                    copy {
                        from(sourceSets.main.resources) {
                            include resourceTargets
                            expand replaceProperties
                        }
                        into target
                    }
                }
            }
        }
        // Copies the correct accesswidener and renames it
        task copyAccessWidener(type: Copy) {
            from project(":common").file("src/main/resources/${rootProject.acsessWidenerVersion}.lod.accesswidener")
            into(file(p.file("build/resources/main")))
            rename "${rootProject.acsessWidenerVersion}.lod.accesswidener", "lod.accesswidener"
        }

        task copyCoreResources(type: Copy) {
            from fileTree(project(":core").file("src/main/resources"))
            into p.file("build/resources/main")
        }

        task copyCommonResources(type: Copy) {
            from fileTree(project(":common").file("src/main/resources"))
            into p.file("build/resources/main")
        }

        p.tasks.withType(JavaCompile) {
            // Add Manifold Preprocessor
//		def excapedMCVersion = rootProject.minecraft_version.replace(".", "_")
//		options.compilerArgs += ['-Xplugin:Manifold', "-AMC_VERSION_${excapedMCVersion}"]
//
            //options.compilerArgs += ['-deprecation']
            //options.compilerArgs += ['-verbose']
            //options.compilerArgs += ['-Xlint:unchecked']
            //options.compilerArgs += ['-Xdiags:verbose']
            //options.compilerArgs += ['-Xprint']
            //options.compilerArgs += ['-XprintProcessorInfo']
            //options.compilerArgs += ['-XprintRounds']

            // println options.compilerArgs

            // Set the java version
            options.release = 8; // Core should use Java 8 no matter what
            // TODO: make everything use java 8
//        options.release = 8 // Use Java 8 for everything so back porting is easier
        }

        java {
            withSourcesJar()
        }

        p.runClient.enabled = false
        p.runServer.enabled = false
    }
}