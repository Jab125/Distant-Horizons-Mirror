plugins {
    // Plugin to help in developing multi-loader mods
    id "architectury-plugin" version "3.4-SNAPSHOT"
    id "dev.architectury.loom" version "0.12.0-SNAPSHOT" apply false

    // Plugin to handle dependencies
    id 'com.github.johnrengelman.shadow' version '7.0.0' apply false

    // Plugin to create merged jars
//    id "io.github.pacifistmc.forgix" version "1.2.6"

    // Provides mc libraries to core
    id 'org.spongepowered.gradle.vanilla' version '0.2.1-SNAPSHOT' apply false
}

/**
 * Creates the list of preprocessors to use.
 *
 * @param mcVers array of all MC versions
 * @param mcIndex array index of the currently active MC version
 */
def writeBuildGradlePredefine(List<String> mcVers, int mcIndex) {

    ArrayList<String> redefineList = new ArrayList<String>()
    for (int i=0; i<mcVers.size(); i++) {
        String mcStr = mcVers.get(i).replace(".", "_")
        if (mcIndex<i) {
            redefineList.add("PRE_MC_"+mcStr)
        }
        if (mcIndex==i) {
            redefineList.add("MC_"+mcStr)
        }
        if (mcIndex>=i) {
            redefineList.add("POST_MC_"+mcStr)
        }
    }

    // build the list of preprocessors to use
    StringBuilder sb = new StringBuilder()

    // check if this is a development build
    if (mod_version.toLowerCase().contains("dev")) {
        // WARNING: only use this for logging, we don't want to have confusion
        // when a method doesn't work correctly in the release build.
        sb.append("DEV_BUILD")
        sb.append("=\n")
    }

    // build the MC version preprocessors
    for (String redefinedVersion : redefineList) {
        sb.append(redefinedVersion)
        sb.append("=\n")
    }
    new File(projectDir, "build.properties").text = sb.toString()
}

// Sets up the variables for Manifold in the code
def loadProperties() {
    def defaultMcVersion = "1.19.2"
//    def defaultMcVersion = "1.19" // For now use 1.18.2 as default until 1.19 is done
    def mcVersion = ""
    def mcVers = mcVersions.split(",")
    int mcIndex = -1
    println "Avalible MC versions: ${mcVersions}"
    if (project.hasProperty("mcVer")) {
        mcVersion = mcVer
        mcIndex = Arrays.asList(mcVers).indexOf(mcVer)
    }
    if (mcIndex == -1) {
        println "No mcVer set or the set mcVer is invalid! Defaulting to ${defaultMcVersion}."
        println "Tip: Use -PmcVer='${defaultMcVersion}' in cmd arg to set mcVer."
        mcVersion = defaultMcVersion
        mcIndex = Arrays.asList(mcVers).indexOf(defaultMcVersion)
        assert mcIndex != -1
    }

	println "Loading properties file at " + mcVersion + ".properties"
	def props = new Properties()
	props.load(new FileInputStream("$rootProject.rootDir/"+"$mcVersion"+".properties"))

    props.each { prop ->
      rootProject.ext.set(prop.key, prop.value)
	  // println "Added prop [key:" + prop.key + ", value:" + prop.value + "]"
    }
    writeBuildGradlePredefine(Arrays.asList(mcVers), mcIndex)

    // Stuff for access wideners
    def mcVersionToAcsessWidenerVersion = [
            "1.16.5": "1_16",
            "1.17.1": "1_17",
            "1.18.1": "1_18",
            "1.18.2": "1_18",
            "1.19": "1_19",
            "1.19.1": "1_19",
            "1.19.2": "1_19"
    ]
    // Use this as sometimes multiple versions use the same access wideners
    rootProject.ext.set("accessWidenerVersion", mcVersionToAcsessWidenerVersion.get(mcVersion))
}
loadProperties()

// Sets up the accesswideners
def makeAccessWidener() {
    def accessWidenerFile = project(":common").file("src/main/resources/lod.accesswidener")
    if (accessWidenerFile.exists()) {
        delete accessWidenerFile
    }

    copy {
        from project(":common").file("src/main/resources/${rootProject.accessWidenerVersion}.lod.accesswidener")
        into project(":common").file("src/main/resources/")
        rename "${rootProject.accessWidenerVersion}.lod.accesswidener", "lod.accesswidener"
    }
}
makeAccessWidener()




// Sets up the version string
rootProject.versionStr = rootProject.mod_version + "-" + rootProject.minecraft_version // + "-" + new Date().format("yyyy_MM_dd_HH_mm")

// Merged jar settings
//forgix {
//    group = "com.seibel.lod"
//    mergedJarName = "DistantHorizons-${rootProject.versionStr}.jar"
//
//    forge {
//        jarLocation = "build/libs/DistantHorizons-${rootProject.versionStr}.jar"
//    }
//
//    fabric {
//        jarLocation = "build/libs/DistantHorizons-${rootProject.versionStr}.jar"
//    }
//
//    removeDuplicate "com.seibel.lod.api"
//    removeDuplicate "com.seibel.lod.core"
//}

architectury {
    minecraft = rootProject.minecraft_version
}

subprojects { p ->
    
    // setup Architectury
    if (p == project(":core") || p == project(":api")) {
        apply plugin: "application"
        apply plugin: "org.spongepowered.gradle.vanilla" // Provides minecraft libraries
        apply plugin: "com.github.johnrengelman.shadow"
    } else {
        apply plugin: "com.github.johnrengelman.shadow"
        apply plugin: "dev.architectury.loom"
        
        loom {
            silentMojangMappingsLicense()
        }
    }

    // set up custom configurations (configurations are a way to handle dependencies) 
    configurations {
        // extends the shadowJar configuration 
        shadowMe
        // have implemented dependencies automatically embedded in the final jar
        implementation.extendsFrom(shadowMe)
        
        customModule
        implementation.extendsFrom(customModule)
    }
    
    // Set up the minecraft non-dependency for core sub-projects
    if (p == project(":core") || p == project(":api")) {
        minecraft {
            version("${rootProject.minecraft_version}")
        }

        // Set the standalone jar entrypoint
        // (This will point to a non-existent class in all sub-projects except "Core")
        application {
            mainClass.set('com.seibel.lod.core.jar.JarMain')
        }
    }

    dependencies {
        
        //=====================//
        // shared dependencies //
        //=====================//
        

        // Manifold
        annotationProcessor("systems.manifold:manifold-preprocessor:${rootProject.manifold_version}")

        // JUnit tests
        implementation("org.junit.jupiter:junit-jupiter:5.8.2")
        implementation("org.junit.jupiter:junit-jupiter-engine:5.8.2")
        implementation("junit:junit:4.13")
        
        // Compression
        shadowMe("org.tukaani:xz:1.9")
        shadowMe("org.apache.commons:commons-compress:1.21")

        // NightConfig (includes Toml & Json)
        shadowMe("com.electronwill.night-config:toml:${rootProject.nightconfig_version}")
        shadowMe("com.electronwill.night-config:json:${rootProject.nightconfig_version}")

        // Theming
        shadowMe("com.formdev:flatlaf:${rootProject.flatlaf_version}")

        // SVG
        shadowMe("com.formdev:flatlaf-extras:${rootProject.flatlaf_version}")
        shadowMe("com.formdev:svgSalamander:${rootProject.svgSalamander_version}")
        
        
        
        //==========================//
        // conditional dependencies //
        //==========================//

        // The logic for buildForge can be made more succinct, but the readability goes way down.
        def buildForge = true
        if (gradle.startParameter.taskRequests.size() > 0) {
            if (gradle.startParameter.taskRequests[0].args.size() > 0) {
                if (gradle.startParameter.taskRequests[0].args[0].startsWith("fabric:")) {
                    buildForge = false
                }
            }
        }

        // Minecraft dependent sub-projects
        if (p == project(":common") || (buildForge && p == project(":forge")) || p == project(":fabric")) {
            // Add Minecraft
            minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
            // The following line declares the mojmap mappings & parchment mappings
            mappings loom.layered() {
                // Mojmap mappings
                officialMojangMappings()
                // Parchment mappings (it adds parameter mappings & javadoc)
                parchment("org.parchmentmc.data:parchment-${rootProject.minecraft_version}:${rootProject.parchment_version}@zip")
            }
        }

        // Add core
        if (p != project(":api") && p != project(":core")) {
            implementation(project(":core")) {
                // Remove Junit test libraries
                exclude group: "org.junit.jupiter", module: "junit-jupiter"
                exclude group: "org.junit.jupiter", module: "junit-jupiter-engine"
                exclude group: "junit", module: "junit"
            }
        }

        // Add the api
        if (p != project(":api")) {
            implementation(project(":api")) {
                // Remove Junit test libraries
                exclude group: "org.junit.jupiter", module: "junit-jupiter"
                exclude group: "org.junit.jupiter", module: "junit-jupiter-engine"
                exclude group: "junit", module: "junit"
            }
        }
    }

    // Allows the jar to run standalone
    jar {
        manifest {
            attributes 'Implementation-Title': rootProject.archives_base_name,
                    'Implementation-Version': rootProject.mod_version,
                    'Main-Class': 'com.seibel.lod.core.jar.JarMain' // When changing the main of the jar change this line
        }
    }

    // this can be un-commented if we ever wanted to make DH modular (AKA use a module-info.java file) again
//    // Tells gradle where to look for other modules
//    // Why isn't the classpath added to the modules path by default?
//    if (p == project(":core")) {
//        compileJava {
//            inputs.property('moduleName', 'dhApi')
//            doFirst {
//                options.compilerArgs = [
//                        '--module-path', classpath.asPath
//                ]
//                classpath = files()
//            }
//        }
//    }

    // Run mergeJars when running build
//    if (p != project(":api") && p != project(":api")) {
//        build.finalizedBy(mergeJars)
//        assemble.finalizedBy(mergeJars)
//    }
}

allprojects { p ->
    apply plugin: "java"
    apply plugin: "architectury-plugin"
    apply plugin: "maven-publish"

    archivesBaseName = rootProject.archives_base_name
    version = rootProject.mod_version
    group = rootProject.maven_group

    repositories {
        mavenCentral()

        // For parchment mappings
        maven { url "https://maven.parchmentmc.org" }

        // For Architectury API
        maven { url "https://maven.architectury.dev" }

        // used to download and compile dependencies from git repos
        maven { url 'https://jitpack.io' }

        // For Manifold Preprocessor
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }

        // Required for importing Modrinth mods
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }

        // Required for importing CursedForge mods
        maven {
            url "https://www.cursemaven.com"
            content {
                includeGroup "curse.maven"
            }
        }

        // Required for ModMenu
        maven { url "https://maven.terraformersmc.com/" }

        // Required for Mixins & VanillaGradle
        maven { url "https://repo.spongepowered.org/maven/" }

        // Required for canvas
        maven { url "https://maven.vram.io/" }

        // These 2 are for importing mods that arnt on CursedForge, Modrinth, GitHub, GitLab or anywhere opensource
        flatDir {
            dirs "${rootDir}/mods/fabric"
            content {
                includeGroup "fabric-mod"
            }
        }
        flatDir {
            dirs "${rootDir}/mods/forge"
            content {
                includeGroup "forge-mod"
            }
        }
    }


    // Only uncomment this when testing stuff with lwjgl in the core jar
//    if (p == project(":core")) {
//        dependencies {
//            project.ext.lwjglNatives = "natives-linux"
//
//            implementation platform("org.lwjgl:lwjgl-bom:3.3.0")
//
//            implementation "org.lwjgl:lwjgl"
//            implementation "org.lwjgl:lwjgl-assimp"
//            implementation "org.lwjgl:lwjgl-glfw"
//            implementation "org.lwjgl:lwjgl-openal"
//            implementation "org.lwjgl:lwjgl-opengl"
//            implementation "org.lwjgl:lwjgl-stb"
//            implementation "org.lwjgl:lwjgl-tinyfd"
//            runtimeOnly "org.lwjgl:lwjgl::$lwjglNatives"
//            runtimeOnly "org.lwjgl:lwjgl-assimp::$lwjglNatives"
//            runtimeOnly "org.lwjgl:lwjgl-glfw::$lwjglNatives"
//            runtimeOnly "org.lwjgl:lwjgl-openal::$lwjglNatives"
//            runtimeOnly "org.lwjgl:lwjgl-opengl::$lwjglNatives"
//            runtimeOnly "org.lwjgl:lwjgl-stb::$lwjglNatives"
//            runtimeOnly "org.lwjgl:lwjgl-tinyfd::$lwjglNatives"
//            implementation "org.joml:joml:1.10.2"
//        }
//    }

    // Put stuff from gradle.properties into the mod info
    processResources {
        def resourceTargets = ["fabric.mod.json", "META-INF/mods.toml"] // Location of where to put
        def intoTargets = ["$buildDir/resources/main/"] // Location of the built resources folder
        def replaceProperties = [
                version                      : mod_version,
                mod_name                     : mod_name,
                authors                      : mod_authors,
                description                  : mod_description,
                homepage                     : mod_homepage,
                source                       : mod_source,
                issues                       : mod_issues,
                minecraft_version            : minecraft_version,
                compatible_minecraft_versions: compatible_minecraft_versions,
                java_version                 : java_version
        ]
        // The left side is what gets replaced in the mod info and the right side is where to get it from in the gradle.properties
        //TODO: Make Forge loader version also be relaced with non hardcoded value instead of "[36,42)"

        inputs.properties replaceProperties
        replaceProperties.put 'project', project
        filesMatching(resourceTargets) {
            expand replaceProperties
        }

        intoTargets.each { target ->
            if (file(target).exists()) {
                copy {
                    from(sourceSets.main.resources) {
                        include resourceTargets
                        expand replaceProperties
                    }
                    into target
                }
            }
        }
    }

    task copyCoreResources(type: Copy) {
        from fileTree(project(":core").file("src/main/resources"))
        into p.file("build/resources/main")
    }

    tasks.withType(JavaCompile) {
        if (p != project(":core")) {
            options.release = rootProject.java_version as Integer
            options.compilerArgs += ['-Xplugin:Manifold']
        } else {
//             options.release = 8; // Core should use Java 8 no matter what
            // No it shouldn't cause it fails to find minecraft if it uses Java 8
            options.release = rootProject.java_version as Integer
        }
        options.encoding = "UTF-8"
    }

    java {
        withSourcesJar()
    }

    // Disable running common
    if (p == project(":common")) {
        runClient.enabled = false
        runServer.enabled = false
    }
}

// Delete the merged folder when running clean
task cleanMergedJars() {
    def mergedFolder = file("Merged")
    if (mergedFolder.exists()) {
        delete(mergedFolder)
    }
}
// add cleanMergedJars to the end of the "clean" task
tasks["clean"].finalizedBy(cleanMergedJars)
