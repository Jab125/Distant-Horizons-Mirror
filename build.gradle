import io.github.ran.jarmerger.JarMergerPlugin


buildscript {
    dependencies{
        classpath files('plugins/DHJarMerger-1.0.jar')
    }
}

plugins {
    id "architectury-plugin" version "3.4-SNAPSHOT"
    id "dev.architectury.loom" version "0.11.0-SNAPSHOT" apply false
}

def writeBuildGradlePredefine(List<String> mcVers, int mcIndex) {
    ArrayList<String> redefineList = new ArrayList<String>()
    for (int i=0; i<mcVers.size(); i++) {
        String mcStr = mcVers.get(i).replace(".", "_")
        if (mcIndex<i) {
            redefineList.add("PRE_MC_"+mcStr)
        }
        if (mcIndex==i) {
            redefineList.add("MC_"+mcStr)
        }
        if (mcIndex>=i) {
            redefineList.add("POST_MC_"+mcStr)
        }
    }
    StringBuilder sb = new StringBuilder()
    for (String s : redefineList) {
        sb.append(s)
        sb.append("=\n")
    }
    new File(projectDir, "build.properties").text = sb.toString()
}

// Sets up the variables for Manifold in the code
def loadProperties() {
    def defaultMcVersion = "1.18.2"
    def mcVersion = ""
    def mcVers = mcVersions.split(",")
    int mcIndex = -1
    println "Avalible MC versions: ${mcVersions}"
    if (project.hasProperty("mcVer")) {
        mcVersion = mcVer
        mcIndex = Arrays.asList(mcVers).indexOf(mcVer)
    }
    if (mcIndex == -1) {
        println "No mcVer set or the set mcVer is invalid! Defaulting to ${defaultMcVersion}."
        println "Tip: Use -PmcVer='${defaultMcVersion}' in cmd arg to set mcVer."
        mcVersion = defaultMcVersion
        mcIndex = Arrays.asList(mcVers).indexOf(defaultMcVersion)
        assert mcIndex != -1
    }

	println "Loading properties file at " + mcVersion + ".properties"
	def props = new Properties()
	props.load(new FileInputStream("$rootProject.rootDir/"+"$mcVersion"+".properties"))

    props.each { prop ->
      rootProject.ext.set(prop.key, prop.value)
	  // println "Added prop [key:" + prop.key + ", value:" + prop.value + "]"
    }
    writeBuildGradlePredefine(Arrays.asList(mcVers), mcIndex)

    // Stuff for access wideners
    def mcVersionToAcsessWidenerVersion = [
            "1.16.5": "1_16",
            "1.17.1": "1_17",
            "1.18.1": "1_18",
            "1.18.2": "1_18",
            "1.19"  : "1_19"
    ]
    // Use this as sometimes multiple versions use the same access wideners
    rootProject.ext.set("acsessWidenerVersion", mcVersionToAcsessWidenerVersion.get(mcVersion))
}
loadProperties()

apply plugin: JarMergerPlugin

architectury {
    minecraft = rootProject.minecraft_version
}


subprojects { p ->
    apply plugin: "dev.architectury.loom"

    loom {
        silentMojangMappingsLicense()

        if (p != project(":core")) {
            accessWidenerPath.set(project(":common").file("src/main/resources/${acsessWidenerVersion}.lod.accesswidener"))
        }
    }

    configurations {
        common
        shadowMe
        implementation.extendsFrom shadowMe
    }

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
        // The following line declares the mojmap mappings & parchment mappings
        mappings loom.layered() {
            // Mojmap mappings
            officialMojangMappings()
            // Parchment mappings (it adds parameter mappings & javadoc)
//            parchment("org.parchmentmc.data:parchment-${rootProject.minecraft_version}:${rootProject.parchment_version}@zip")
        }

		//Manifold
		annotationProcessor "systems.manifold:manifold-preprocessor:${rootProject.manifold_version}"

        // Toml
        implementation("com.electronwill.night-config:toml:${rootProject.toml_version}")

        if (p != project(":forge")) {
            // We depend on fabric loader here to use the fabric @Environment annotations and get the mixin dependencies
            // Do NOT use other classes from fabric loader unless working with fabric
            modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
        }

        if (p == project(":common")) {
            common(project(":core")) { transitive false }
            shadowMe(project(":core")) { transitive false }
        }
    }

    // Allows the jar to run standalone
    jar {
        manifest {
            attributes 'Implementation-Title': rootProject.archives_base_name,
                    'Implementation-Version': rootProject.mod_version,
                    'Main-Class': 'com.seibel.lod.core.JarMain' // When changing the main of the jar change this line
        }
    }
}

allprojects { p ->
    apply plugin: "java"
    apply plugin: "architectury-plugin"
    apply plugin: "maven-publish"

    archivesBaseName = rootProject.archives_base_name
    version = rootProject.mod_version
    group = rootProject.maven_group


    repositories {
        mavenCentral()

        // For parchment mappings
        maven { url "https://maven.parchmentmc.org" }

        // used to download and compile dependencies from git repos
        maven { url 'https://jitpack.io' }

        // For Manifold Preprocessor
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }

        // Required for importing Modrinth mods
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }

        // Required for importing CursedForge mods
        maven {
            url "https://www.cursemaven.com"
            content {
                includeGroup "curse.maven"
            }
        }

        // These 2 are for importing mods that arnt on CursedForge, Modrinth, GitHub, GitLab or anywhere opensource
        flatDir {
            dirs "${rootDir}/mods/fabric"
            content {
                includeGroup "fabric-mod"
            }
        }
        flatDir {
            dirs "${rootDir}/mods/forge"
            content {
                includeGroup "forge-mod"
            }
        }
    }


    // Put stuff from gradle.properties into the mod info
    processResources {
        def resourceTargets = ["fabric.mod.json", "META-INF/mods.toml"] // Location of where to put
        def intoTargets = ["$buildDir/resources/main/"] // Location of the built resources folder
        def replaceProperties = [
                version                      : mod_version,
                mod_name                     : mod_name,
                authors                      : mod_authors,
                description                  : mod_description,
                homepage                     : mod_homepage,
                source                       : mod_source,
                issues                       : mod_issues,
                minecraft_version            : minecraft_version,
                compatible_minecraft_versions: compatible_minecraft_versions,
                java_version                 : java_version
        ]
        // The left side is what gets replaced in the mod info and the right side is where to get it from in the gradle.properties
        //TODO: Make Forge loader version also be relaced with non hardcoded value instead of "[36,41)"

        inputs.properties replaceProperties
        replaceProperties.put 'project', project
        filesMatching(resourceTargets) {
            expand replaceProperties
        }

        intoTargets.each { target ->
            if (file(target).exists()) {
                copy {
                    from(sourceSets.main.resources) {
                        include resourceTargets
                        expand replaceProperties
                    }
                    into target
                }
            }
        }
    }


    // Copies the correct accesswidener and renames it
    task copyAccessWidener(type: Copy) {
        from project(":common").file("src/main/resources/${rootProject.acsessWidenerVersion}.lod.accesswidener")
        into(file(p.file("build/resources/main")))
        rename "${rootProject.acsessWidenerVersion}.lod.accesswidener", "lod.accesswidener"
    }

    task copyCoreResources(type: Copy) {
        from fileTree(project(":core").file("src/main/resources"))
        into p.file("build/resources/main")
    }

    task copyCommonResources(type: Copy) {
        from fileTree(project(":common").file("src/main/resources"))
        into p.file("build/resources/main")
    }


    // Is this necessary for running the fabric build
    if (p == project(":common")) {
        println "Copying [common/src/main/resources/${acsessWidenerVersion}.lod.accesswidner] to [fabric/build/resources/main]."

        copy {
            from project(":common").file("src/main/resources/${acsessWidenerVersion}.lod.accesswidener")
            into project(":fabric").file("build/resources/main")
            rename "${acsessWidenerVersion}.lod.accesswidener", "lod.accesswidener"
        }
    }

    tasks.withType(JavaCompile) {
        // Add Manifold Preprocessor
//		def excapedMCVersion = rootProject.minecraft_version.replace(".", "_")
//		options.compilerArgs += ['-Xplugin:Manifold', "-AMC_VERSION_${excapedMCVersion}"]
//
        //options.compilerArgs += ['-deprecation']
        //options.compilerArgs += ['-verbose']
        //options.compilerArgs += ['-Xlint:unchecked']
        //options.compilerArgs += ['-Xdiags:verbose']
        //options.compilerArgs += ['-Xprint']
        //options.compilerArgs += ['-XprintProcessorInfo']
        //options.compilerArgs += ['-XprintRounds']

        // println options.compilerArgs

        // Set the java version
        if (p != project(":core")) {
            options.compilerArgs += ['-Xplugin:Manifold']
            options.release = rootProject.java_version as Integer
        } else if (p == project(":core")) {
            options.release = 8; // Core should use Java 8 no matter what
        }
        // TODO: make everything use java 8
//        options.release = 8 // Use Java 8 for everything so back porting is easier
    }

    java {
        withSourcesJar()
    }

    // Disable running the core and common
    if (p == project(":core") || p == project(":common")) {
        runClient.enabled = false
        runServer.enabled = false
    }
}


// this deletes the merged folder so we don't carry over
// the previous merges to each new build job in the CI/CD pipeline
task deleteMerged(type: Delete) {
   delete files("./Merged")
}
