package com.seibel.lod.objects;

import java.awt.Color;

import com.seibel.lod.enums.ColorDirection;
import com.seibel.lod.enums.LodDetail;
import com.seibel.lod.handlers.LodDimensionFileHandler;
import com.seibel.lod.util.LodConfig;

import net.minecraft.util.math.ChunkPos;

/**
 * This object contains position
 * and color data for an LOD object.
 * 
 * @author James Seibel
 * @version 6-12-2021
 */
public class LodChunk
{
	/** how many different pieces of data are in one line */
	private static final int DATA_DELIMITER_COUNT = 22;

	/** This is what separates each piece of data in the toData method */
	private static final char DATA_DELIMITER = LodDimensionFileHandler.DATA_DELIMITER;
	
	/** Width of a Minecraft Chunk */
	public static final int WIDTH = 16;
	
	/** alpha used when drawing chunks in debug mode */
	private static final int DEBUG_ALPHA = 255; // 0 - 255
	private static final Color DEBUG_BLACK = new Color(0, 0, 0, DEBUG_ALPHA);
	private static final Color DEBUG_WHITE = new Color(255, 255, 255, DEBUG_ALPHA);
	private static final Color INVISIBLE = new Color(0,0,0,0);
	
	
	public static final LodDetail DETAIL = LodDetail.QUAD;
	
	
	/** The x coordinate of the chunk. */
	public int x = 0;
	/** The z coordinate of the chunk. */
	public int z = 0;
	
	
	/** This stores the height and color for each data point in the LodChunk */
	public LodDataPoint dataPoints[][];
	
	/** If true then this LodChunk contains no data */
	private boolean empty = false;
	
	
	/**
	 * Create an empty invisible LodChunk at (0,0)
	 */
	public LodChunk()
	{
		empty = true;
		
		x = 0;
		z = 0;
		
		dataPoints = new LodDataPoint[DETAIL.lengthCount][DETAIL.lengthCount];
	}
	
	
	// TODO
	/**
	 * Creates an LodChunk from the string
	 * generated by the toData method.
	 * 
	 * @throws IllegalArgumentException if the data isn't valid to create a LodChunk
	 * @throws NumberFormatException if any piece of data can't be converted at any point
	 */
//	public LodChunk(String data) throws IllegalArgumentException, NumberFormatException
//	{
//		/*
//		 * data format:
//		 * x, z, height, depth, rgb color data
//		 * 
//		 * example:
//		 * 5,8, 4, 0, 255,255,255, 255,255,255, 255,255,255, 255,255,255, 255,255,255, 255,255,255,
//		 */
//		
//		// make sure there are the correct number of entries
//		// in the data string (28)
//		int count = 0;
//		
//		for(int i = 0; i < data.length(); i++)
//			if(data.charAt(i) == DATA_DELIMITER)
//				count++;
//		
//		if(count != DATA_DELIMITER_COUNT)
//			throw new IllegalArgumentException("LodChunk constructor givin an invalid string. The data given had " + count + " delimiters when it should have had " + DATA_DELIMITER_COUNT + ".");
//		
//		
//		
//		// index we will use when going through the String
//		int index = 0;
//		int lastIndex = 0;
//		
//		
//		
//		// x and z position
//		index = data.indexOf(DATA_DELIMITER, 0);
//		x = Integer.parseInt(data.substring(0,index));
//		
//		lastIndex = index;
//		index = data.indexOf(DATA_DELIMITER, lastIndex+1);
//		z = Integer.parseInt(data.substring(lastIndex+1,index));
//		
//		// height
//		lastIndex = index;
//		index = data.indexOf(DATA_DELIMITER, lastIndex+1);
//		// TODO
//		//height = Short.parseShort(data.substring(lastIndex+1,index));
//		
//		// depth
//		lastIndex = index;
//		index = data.indexOf(DATA_DELIMITER, lastIndex+1);
//		//depth = Short.parseShort(data.substring(lastIndex+1,index));
//		
//		
//		
//		// color
//		//colors = new Color[6];
//		for(ColorDirection dir : ColorDirection.values())
//		{
//			int red = 0;
//			int green = 0;
//			int blue = 0;
//			
//			// get r,g,b
//			for(int i = 0; i < 3; i++)
//			{
//				lastIndex = index;
//				index = data.indexOf(DATA_DELIMITER, lastIndex + 1);
//				
//				String raw = "";
//				switch(i)
//				{
//				case 0:
//					raw = data.substring(lastIndex+1,index);
//					red = Short.parseShort(raw);
//					break;
//				case 1:
//					raw = data.substring(lastIndex+1,index);
//					green = Short.parseShort(raw);
//					break;
//				case 2:
//					raw = data.substring(lastIndex+1,index);
//					blue = Short.parseShort(raw);
//					break;
//				}
//			}
//			
//			// TODO
//			//colors[dir.value] = new Color(red, green, blue);
//		}
//		
//		
//		// after going through all this
//		// is this LOD empty?
//		empty = determineIfEmtpy();
//	}
	
	/**
	 * Create a LodChunk from the given values.
	 */
	public LodChunk(ChunkPos pos, LodDataPoint[][] newDataPoints)
	{
		x = pos.x;
		z = pos.z;
		
		dataPoints = newDataPoints;
		
		empty = determineIfEmtpy();
	}
	
	
	
	
	
	
	//================//
	// misc functions //
	//================//
	
	/**
	 * Returns true if this LodChunk is an emptyPlaceholder
	 */
	public boolean isPlaceholder()
	{
		return empty;
	}
	
	public boolean isLodEmpty()
	{
		return empty;
	}
	
	/**
	 * Returns true if this LOD is either invisible
	 * from every direction or doesn't have a valid height.
	 */
	private boolean determineIfEmtpy()
	{
		for(LodDataPoint[] dataPointArray : dataPoints)
		{
			for(LodDataPoint dataPoint : dataPointArray)
			{
				if (dataPoint == null)
					continue;
				
				// we don't check the depth since the
				// height should always be greater than or equal
				// to the depth
				if(dataPoint.height >= 0)
				{
					// the height is valid,
					// do we have at least 1 non-invisible color?
					for(ColorDirection dir : ColorDirection.values())
						if(!dataPoint.colors[dir.value].equals(INVISIBLE))
							// at least one direction has a non-invisible color
							return false;
				}
			}
		}
		
		// we checked everywhere, this LodChunk is empty
		return true;
	}
	
	
	
	
	//========//
	// output //
	//========//
	
	/**
	 * Returns the data point for the given relative block position.
	 */
	public LodDataPoint getDataPointForBlockPos(int blockX, int blockZ)
	{
		if (blockX < 0 || blockX > WIDTH || blockX < 0 || blockZ > WIDTH)
			throw new IllegalArgumentException("The coordinates given are outside the LodChunk");
		
		return dataPoints[blockX / DETAIL.width][blockZ / DETAIL.width];
	}
	
	/** Returns the color for the given direction */
	public Color getColorForBlockPos(int blockX, int blockZ, ColorDirection dir)
	{
		return getDataPointForBlockPos(blockX, blockZ).colors[dir.value];
	}
	
	public short getHeightForBlockPos(int blockX, int blockZ)
	{
		return getDataPointForBlockPos(blockX, blockZ).height;
	}
	
	public short getDepthForBlockPos(int blockX, int blockZ)
	{
		return getDataPointForBlockPos(blockX, blockZ).depth;
	}
	
	
	/**
	 * @param startX
	 * @param startZ
	 * @param endX
	 * @param endZ
	 * @return
	 */
	public short getAverageHeightOverArea(int startX, int startZ, int endX, int endZ)
	{
		int average = 0;
		
		for(int x = startX; x < endX; x++)
			for(int z = startZ; z < endZ; z++)
				average += getHeightForBlockPos(x,z);
		
		return (short) (average / ((endX - startX) * (endZ - startZ)));
	}
	
	/**
	 * @param startX
	 * @param startZ
	 * @param endX
	 * @param endZ
	 * @return
	 */
	public short getAverageDepthOverArea(int startX, int startZ, int endX, int endZ)
	{
		int average = 0;
		
		for(int x = startX; x < endX; x++)
			for(int z = startZ; z < endZ; z++)
				average += getDepthForBlockPos(x,z);
		
		return (short) (average / ((endX - startX) * (endZ - startZ)));
	}
	
	
	/**
	 * Determine the color for each side of this LOD.
	 */
	public Color[] getAverageColorOverArea(int startX, int startZ, int endX, int endZ, boolean debugging)
	{
		Color[] colors = new Color[ColorDirection.values().length];
		
		for(int x = startX; x < endX; x++)
		{
			for(int z = startZ; z < endZ; z++)
			{
				if (!debugging)
				{
					// if NOT debugging, look to the config to determine
					// how this LOD should be colored
					switch (LodConfig.CLIENT.lodColorStyle.get())
					{
					case TOP:
						// only add the top's color to the array
						for(ColorDirection dir : ColorDirection.values())
							colors[dir.value] = getColorForBlockPos(x,z, ColorDirection.TOP);
						break;
						
					case INDIVIDUAL_SIDES:
						// add each direction's color to the array
						for(ColorDirection dir : ColorDirection.values())
							colors[dir.value] = getColorForBlockPos(x,z, dir);
						break;
					}
				}
				else
				{
					// if debugging draw the squares as a black and white checker board
					if ((x + z) % 2 == 0)
						for(ColorDirection dir : ColorDirection.values())
							// have each direction be the same
							// color if debugging
							colors[dir.value] = DEBUG_WHITE;
					else
						for(ColorDirection dir : ColorDirection.values())
							colors[dir.value] = DEBUG_BLACK;
				}
			}
		}
		
		return colors;
	}
	
	
	
	
	/**
	 * Outputs all data in a csv format
	 * with the given delimiter.
	 * <br>
	 * Exports data in the form:
	 * <br>
	 * x, z, height, depth, rgb color data
	 * 
	 * <br>
	 * example output:
	 * <br>
	 * 5,8, 4, 0, 255,255,255, 255,255,255, 255,255,255, 255,255,255, 255,255,255, 255,255,255,
	 */
	public String toData()
	{
		String s = "";
		
		s += Integer.toString(x) + DATA_DELIMITER +  Integer.toString(z) + DATA_DELIMITER;
		
		for (LodDataPoint[] dataPointArray : dataPoints)
			for(LodDataPoint dataPoint : dataPointArray)
				s += dataPoint.toData();
		
		return s;
	}
	
	
	@Override
	public String toString()
	{
		String s = "";
		
		s += "x: " + x + " z: " + z + "\t";
		
		// TODO
		//s += "(" + colors[ColorDirection.TOP.value].getRed() + ", " + colors[ColorDirection.TOP.value].getGreen() + ", " + colors[ColorDirection.TOP.value].getBlue() + ")";
		
		return s;
	}
}
