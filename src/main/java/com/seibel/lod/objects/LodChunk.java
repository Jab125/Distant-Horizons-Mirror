package com.seibel.lod.objects;

import java.awt.Color;

import com.seibel.lod.enums.LodDetail;
import com.seibel.lod.handlers.LodDimensionFileHandler;

import net.minecraft.util.math.ChunkPos;
import net.minecraft.world.gen.Heightmap;

/**
 * This object contains position
 * and color data for an LOD object.
 * 
 * @author James Seibel
 * @version 6-27-2021
 */
public class LodChunk
{
	/** This is what separates each piece of data in the toData method */
	private static final char DATA_DELIMITER = LodDimensionFileHandler.DATA_DELIMITER;
	
	/** Width of a Minecraft Chunk */
	public static final int WIDTH = 16;
	
	/** alpha used when drawing chunks in debug mode */
	private static final int DEBUG_ALPHA = 255; // 0 - 255
	private static final Color DEBUG_BLACK = new Color(0, 0, 0, DEBUG_ALPHA);
	private static final Color DEBUG_WHITE = new Color(255, 255, 255, DEBUG_ALPHA);
	private static final Color INVISIBLE = new Color(0,0,0,0);
	
	/** If we ever have to use a heightmap for any reason, use this one. */
	public static final Heightmap.Type DEFAULT_HEIGHTMAP = Heightmap.Type.WORLD_SURFACE_WG;
	
	
	public LodDetail detail = LodDetail.SINGLE;
	
	/** If this is set to true then toData will return
	 * the empty string */
	public boolean dontSave = false;
	
	// TODO store the DistanceGenerationMethod used for this chunk (so we can upgrade old chunks if we want to)
	
	
	/** The x coordinate of the chunk. */
	public int x = 0;
	/** The z coordinate of the chunk. */
	public int z = 0;
	
	
	/** This stores the height and color for each data point in the LodChunk */
	public LodDataPoint dataPoints[][];
	
	/** If true then this LodChunk contains no data */
	private boolean empty = false;
	
	
	/**
	 * Create an empty, invisible, non-saving LodChunk at (0,0)
	 */
	public LodChunk()
	{
		dontSave = true;
		empty = true;
		
		x = 0;
		z = 0;
		
		detail = LodDetail.SINGLE;
		
		dataPoints = new LodDataPoint[detail.dataPointLengthCount][detail.dataPointLengthCount];
	}
	
	/**
	 * Create an empty, invisible, non-saving LodChunk at the given ChunkPos
	 */
	public LodChunk(ChunkPos pos)
	{
		this();
		
		x = pos.x;
		z = pos.z;
	}
	
	/**
	 * Create an empty, invisible, non-saving LodChunk at the given ChunkPos
	 */
	public LodChunk(int newX, int newZ)
	{
		this();
		
		x = newX;
		z = newZ;
	}
	
	
	/**
	 * Creates an LodChunk from the string
	 * generated by the toData method.
	 * 
	 * @throws IllegalArgumentException if the data isn't valid to create a LodChunk
	 * @throws NumberFormatException if any piece of data can't be converted at any point
	 */
	public LodChunk(String data, LodDetail newDetail) throws IllegalArgumentException, NumberFormatException
	{
		/*
		 * data format: 
		 * x, z, dataPoint[0][0], dataPoint[0][1], ... 
		 * x, z,  height, depth, rgb color data,  height, depth, rgb....
		 * 
		 * example:
		 * 5,8,  4, 0, 255,255,255,  4, 0, 255, 255, 255, ...
		 */
		
		dontSave = false;
		
		// make sure there are the correct number of entries
		// in the data string
		int count = 0;
		detail = newDetail;
		
		for(int i = 0; i < data.length(); i++)
			if(data.charAt(i) == DATA_DELIMITER)
				count++;
		
		if(count != detail.lodChunkStringDelimiterCount)
			throw new IllegalArgumentException("LodChunk constructor givin an invalid string. The data given had " + count + " delimiters when it should have had " + detail.lodChunkStringDelimiterCount + ".");
		
		
		dataPoints = new LodDataPoint[detail.dataPointLengthCount][detail.dataPointLengthCount];
		
		// index we will use when going through the String
		int index = 0;
		int lastIndex = 0;
		
		
		
		// x and z position
		index = data.indexOf(DATA_DELIMITER, 0);
		this.x = Integer.parseInt(data.substring(0,index));
		
		lastIndex = index;
		index = data.indexOf(DATA_DELIMITER, lastIndex+1);
		this.z = Integer.parseInt(data.substring(lastIndex+1,index));
		
		
		// LodDataPoints
		for(int blockX = 0; blockX < detail.dataPointLengthCount; blockX++)
		{
			for(int blockZ = 0; blockZ < detail.dataPointLengthCount; blockZ++)
			{
				// height
				lastIndex = index;
				index = data.indexOf(DATA_DELIMITER, lastIndex+1);
				int height = Short.parseShort(data.substring(lastIndex+1,index));
				
				// depth
				lastIndex = index;
				index = data.indexOf(DATA_DELIMITER, lastIndex+1);
				int depth = Short.parseShort(data.substring(lastIndex+1,index));
				
				
				// color
				int red = 0;
				int green = 0;
				int blue = 0;
				
				// get r,g,b
				for(int i = 0; i < 3; i++)
				{
					lastIndex = index;
					index = data.indexOf(DATA_DELIMITER, lastIndex + 1);
					
					String raw = "";
					switch(i)
					{
					case 0:
						raw = data.substring(lastIndex+1,index);
						red = Short.parseShort(raw);
						break;
					case 1:
						raw = data.substring(lastIndex+1,index);
						green = Short.parseShort(raw);
						break;
					case 2:
						raw = data.substring(lastIndex+1,index);
						blue = Short.parseShort(raw);
						break;
					}
				}
				
				dataPoints[blockX][blockZ] = new LodDataPoint((short)height, (short)depth, new Color(red, green, blue));
			}
		}
		
		
		empty = determineIfEmtpy();
	}
	
	/**
	 * Create a LodChunk from the given values.
	 */
	public LodChunk(ChunkPos pos, LodDataPoint[][] newDataPoints, LodDetail newDetail)
	{
		x = pos.x;
		z = pos.z;
		
		dataPoints = newDataPoints;
		
		dontSave = false;
		detail = newDetail;
		
		empty = determineIfEmtpy();
	}
	
	
	
	
	
	
	//================//
	// misc functions //
	//================//
	
	/**
	 * Returns true if this LodChunk is an emptyPlaceholder
	 */
	public boolean isPlaceholder()
	{
		return empty;
	}
	
	public boolean isLodEmpty()
	{
		return empty;
	}
	
	/**
	 * Returns true if this LOD is either invisible
	 * from every direction or doesn't have a valid height.
	 */
	private boolean determineIfEmtpy()
	{
		for(LodDataPoint[] dataPointArray : dataPoints)
		{
			for(LodDataPoint dataPoint : dataPointArray)
			{
				if (dataPoint == null)
					continue;
				
				// we don't check the depth since the
				// height should always be greater than or equal
				// to the depth
				if(dataPoint.height >= 0)
				{
					// the height is valid,
					
					if (dataPoint.color == INVISIBLE)
						continue;
					
					// the color and height are valid
					// this LodChunk isn't empty
					return false;
				}
			}
		}
		
		// we checked everywhere, this LodChunk is empty
		return true;
	}
	
	
	
	
	//========//
	// output //
	//========//
	
	/**
	 * Returns the data point for the given relative block position.
	 */
	public LodDataPoint getDataPointForBlockPos(int blockX, int blockZ)
	{
		return dataPoints[blockX / detail.dataPointWidth][blockZ / detail.dataPointWidth];
	}
	
	public Color getColorForBlockPos(int blockX, int blockZ)
	{
		return getDataPointForBlockPos(blockX, blockZ).color;
	}
	
	public short getHeightForBlockPos(int blockX, int blockZ)
	{
		return getDataPointForBlockPos(blockX, blockZ).height;
	}
	
	public short getDepthForBlockPos(int blockX, int blockZ)
	{
		return getDataPointForBlockPos(blockX, blockZ).depth;
	}
	
	
	public Color getColor(int xIndex, int zIndex)
	{
		return dataPoints[xIndex][zIndex].color;
	}
	
	public short getHeight(int xIndex, int zIndex)
	{
		return dataPoints[xIndex][zIndex].height;
	}
	
	public short getDepth(int xIndex, int zIndex)
	{
		return dataPoints[xIndex][zIndex].depth;
	}
	
	public short calculateHighestPoint()
	{
		short highest = 0;
		
		for(int x = 0; x < detail.dataPointLengthCount; x++)
		{
			for(int z = 0; z < detail.dataPointLengthCount; z++)
			{
				if (getHeight(x,z) > highest)
					highest = getHeight(x,z);
			}
		}
		
		return highest;
	}
	
	
	
	/**
	 * @param startX
	 * @param startZ
	 * @param endX
	 * @param endZ
	 * @return
	 */
	public short getAverageHeightOverArea(int startX, int startZ, int endX, int endZ)
	{
		if (startX == endX || startZ == endZ)
			// we were given an area with 0 blocks in it
			return getHeightForBlockPos(startX,startZ);
		
		int average = 0;
		
		for(int x = startX; x < endX; x++)
			for(int z = startZ; z < endZ; z++)
				average += getHeightForBlockPos(x,z);
		
		return (short) (average / ((endX - startX) * (endZ - startZ)));
	}
	
	/**
	 * @param startX
	 * @param startZ
	 * @param endX
	 * @param endZ
	 * @return
	 */
	public short getAverageDepthOverArea(int startX, int startZ, int endX, int endZ)
	{
		if (startX == endX || startZ == endZ)
			// we were given an area with 0 blocks in it
			return getDepthForBlockPos(startX,startZ);
		
		int average = 0;
		
		for(int x = startX; x < endX; x++)
			for(int z = startZ; z < endZ; z++)
				average += getDepthForBlockPos(x,z);
		
		return (short) (average / ((endX - startX) * (endZ - startZ)));
	}
	
	
	/**
	 * Determine the color of this LOD.
	 */
	public Color getAverageColorOverArea(int startX, int startZ, int endX, int endZ, boolean debugging)
	{
		if (startX == endX || startZ == endZ)
			// we were given an area with 0 blocks in it
			return getColorForBlockPos(startX,startZ);
		
		
		
		int[] colorComponents = new int[3];
		
		
		if (debugging)
		{
			// draw the squares as a black and white,
			// like a checker board
			
			// only return 1 color to prevent
			// getting back gray
			if ((startX + startZ) % 2 == 0)
				return DEBUG_WHITE;
			else
				return DEBUG_BLACK;
		}
		
		
		for(int x = startX; x < endX; x++)
		{
			for(int z = startZ; z < endZ; z++)
			{
				colorComponents = addColorToColorAverages(colorComponents, getColorForBlockPos(x,z));
			}
		}
		
		int numbPoints = ((endX - startX) * (endZ - startZ));
		
		return new Color(colorComponents[0]/numbPoints, colorComponents[1]/numbPoints, colorComponents[2]/numbPoints);
	}
	
	
	private int[] addColorToColorAverages(int[] colorAverages, Color colorToAdd) 
	{
		// convert the colorToAdd to an int array
		float[] colorCompoments = new float[4];
		colorCompoments = colorToAdd.getColorComponents(colorCompoments);
		
		// add each color component to the array
		for(int rgbIndex = 0; rgbIndex < 3; rgbIndex++)
		{
			// * 255 + 0.5 taken from the Color java class
			colorAverages[rgbIndex] += (int) (colorCompoments[rgbIndex] * 255 + 0.5);
		}
		
		return colorAverages;
	}
	
	
	
	
	
	/**
	 * Outputs all data in a csv format
	 * with the given delimiter, if
	 * dontSave is false. <br><br>
	 * 
	 * data format: <br>
	 * x, z, dataPoint[0][0], dataPoint[0][1], ... <br>
	 * x, z, height, depth, rgb color data,   height, depth, rgb.... <br><br>
	 * 
	 * example: <br>
	 * 5,8,  4, 0, 255,255,255,  4, 0, 255, 255, 255, ...
	 */
	public String toData()
	{
		if (dontSave)
			return "";
		
		String s = "";
		s += Integer.toString(x) + DATA_DELIMITER +  Integer.toString(z) + DATA_DELIMITER;
		
		for (int i = 0; i < dataPoints.length; i++)
			for (int j = 0; j < dataPoints[i].length; j++)
				s += dataPoints[i][j].toData();
		
		return s;
	}
	
	
	@Override
	public String toString()
	{
		String s = "";
		
		s += "x: " + x + " z: " + z + "\t";
		
		return s;
	}
	
}
